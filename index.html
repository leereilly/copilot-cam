<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copilot GLB Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .loading-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
            transition: opacity 0.5s;
        }
        #webcamVideo {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid white;
            border-radius: 5px;
            display: none;
            /* Prevent webcam from being mirrored in the preview */
            transform: scaleX(-1);
        }
    </style>
</head>
<body>
    <div class="loading-info" id="loadingInfo">Loading model...</div>
    <video id="webcamVideo" autoplay playsinline muted></video>
    <!-- Include the script at the end of the body for better performance -->
    <script src="share-modal.js" defer></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        // Create camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add point lights for better metallic reflections
        const pointLight1 = new THREE.PointLight(0xffffff, 1, 50);
        pointLight1.position.set(0, 10, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 50);
        pointLight2.position.set(-10, -5, -10);
        scene.add(pointLight2);

        // Add orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Add raycaster for mesh identification
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let modelGroupRef = null;

        // Mouse click handler to identify meshes
        function onMouseClick(event) {
            if (!modelGroupRef) return;
            
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(modelGroupRef.children, true);

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                console.log("ðŸ–±ï¸ Clicked mesh:", clickedMesh.name, "Position:", clickedMesh.position);
                
                // Find the mesh in our materials array
                const materialInfo = modelMaterials.find(item => item.mesh === clickedMesh);
                if (materialInfo) {
                    console.log("ðŸ“‹ Mesh info:", {
                        name: materialInfo.meshName,
                        index: materialInfo.meshIndex,
                        isLeftLens: materialInfo.isLeftLens,
                        isEyes: materialInfo.isEyes,
                        vertices: clickedMesh.geometry?.attributes?.position?.count
                    });
                }
            }
        }

        // Add click event listener
        window.addEventListener('click', onMouseClick, false);

        // Initialize webcam
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamTexture = new THREE.VideoTexture(webcamVideo);
        webcamTexture.minFilter = THREE.LinearFilter;
        webcamTexture.magFilter = THREE.LinearFilter;
        webcamTexture.format = THREE.RGBAFormat;
        webcamTexture.wrapS = THREE.ClampToEdgeWrapping; // Changed from RepeatWrapping
        webcamTexture.wrapT = THREE.ClampToEdgeWrapping; // Changed from RepeatWrapping
        // Don't flip the webcam texture - we'll handle orientation in UV mapping
        webcamTexture.flipY = false;
        
        // Use webcam as environment map
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        let envMap;
        
        // Mode tracking
        let currentMode = 'reflection'; // 'reflection' or 'texture'
        
        // Initialize metal material with webcam reflection
        const createMetalMaterial = () => {
            return new THREE.MeshStandardMaterial({
                color: 0xC0C0C0, // Silver color
                metalness: 0.9,
                roughness: 0.1,
                // Removing envMap reference to avoid shader compilation issues
                // envMap: envMap,
                // envMapIntensity: 1.5,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });
        };
        
        // Initialize video texture material - create different materials for original and mirrored sides
        const createVideoMaterial = (isMirrored = false) => {
            // Clone the webcam texture so we can apply different transformations
            const texture = webcamTexture.clone();
            texture.needsUpdate = true;
            
            // Fix upside-down video by flipping vertically
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.y = -1; // Flip vertically to fix upside-down video
            texture.offset.y = 1;  // Adjust offset to compensate
            
            // For the mirrored side, flip the texture horizontally to counteract the geometric mirroring
            if (isMirrored) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.repeat.x = -1; // Flip horizontally
                texture.offset.x = 1;  // Adjust offset to compensate
            }
            
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.0,  // Reduced metalness for better video visibility
                roughness: 0.1,  // Lower roughness for clearer video
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0,
                emissive: new THREE.Color(0x111111), // Slight emissive to make video more visible
                emissiveMap: texture,
                emissiveIntensity: 0.3
            });
            
            return material;
        };
        
        // Create synthwave glowing material for Eyes meshes
        const createSynthwaveEyesMaterial = () => {
            return new THREE.MeshStandardMaterial({
                color: 0xff0080, // Bright magenta/pink
                emissive: new THREE.Color(0x00ffff), // Cyan emissive glow
                emissiveIntensity: 1.0,
                metalness: 0.0,
                roughness: 0.1,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
        };
        
        // Animation time for synthwave effect
        let synthwaveTime = 0;
        
        // Metal materials array to update
        const modelMaterials = [];
        
        // Create shared materials once to ensure consistent mapping
        let sharedVideoMaterial = null;
        let sharedMetalMaterial = null;
        let sharedSynthwaveEyesMaterial = null;
        
        // Apply material to all meshes in a model
        const applyMaterialToModel = (model, materialType, isMirrored = false) => {
            let material;
            
            // Create or reuse a shared material for consistent appearance across models
            if (materialType === 'metal') {
                if (!sharedMetalMaterial) {
                    sharedMetalMaterial = createMetalMaterial();
                }
                material = sharedMetalMaterial;
            } else if (materialType === 'video') {
                // For video materials, we need different instances for original and mirrored models
                // to handle the texture matrix transformation
                material = createVideoMaterial(isMirrored);
            }
            
            // Apply the material to all meshes
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = material;
                    
                    // Add to materials array for later updates
                    if (!modelMaterials.some(item => item.mesh === child)) {
                        modelMaterials.push({
                            mesh: child,
                            material: material,
                            isMirrored: isMirrored
                        });
                    }
                    
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        };

        // Function to load static environment map as fallback
        function useStaticEnvironmentMap() {
            console.log("Using static environment map as fallback");
            // Simply create a dark gray background instead of using environment mapping
            // to avoid shader compilation issues
            scene.background = new THREE.Color(0x333333);
            scene.environment = null;
            envMap = null;
        }
        
        // Create dynamic environment map from webcam feed
        function updateEnvironmentMap() {
            try {
                // Only update if video is actually playing
                if (webcamVideo.readyState === webcamVideo.HAVE_ENOUGH_DATA) {
                    webcamTexture.needsUpdate = true;
                    
                    // Debug webcam status every few seconds
                    if (Math.random() < 0.01) { // ~1% chance each frame = occasional logging
                        console.log("Webcam active, dimensions:", webcamVideo.videoWidth, "x", webcamVideo.videoHeight);
                        console.log("Video texture update status:", webcamTexture.needsUpdate);
                    }
                    
                    // Skip environment mapping when in texture mode to avoid shader errors
                    if (currentMode === 'texture') {
                        return;
                    }
                    
                    try {
                        // Create a simple 2D texture instead of cube map to avoid shader issues
                        scene.environment = null; // Remove environment mapping
                        
                        // Update all materials directly with simple reflection
                        if (currentMode === 'reflection') {
                            modelMaterials.forEach(item => {
                                if (item.mesh && item.mesh.material) {
                                    // Use simpler reflection approach
                                    item.mesh.material.envMap = null;
                                    item.mesh.material.needsUpdate = true;
                                }
                            });
                        }
                    } catch (renderError) {
                        console.error("Error with webcam texture:", renderError);
                        // If we fail with webcam, fall back to static
                        useStaticEnvironmentMap();
                        // Stop trying to update from webcam
                        return;
                    }
                } else {
                    console.log("Waiting for video data, current state:", webcamVideo.readyState);
                }
                
                // Continue updating
                requestAnimationFrame(updateEnvironmentMap);
            } catch (error) {
                console.error("Fatal error updating environment map:", error);
                // Fall back to static environment map
                useStaticEnvironmentMap();
            }
        }
        
        // Start webcam automatically
        function startWebcam() {
            console.log("Starting webcam access...");
            
            // Check for secure context
            if (window.isSecureContext === false) {
                console.warn("Not in a secure context - webcam might not work");
                loadingInfo.innerHTML = "Warning: Site not in secure context. Webcam may not work. Try using HTTPS or localhost.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
            }
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                // Add loading message
                loadingInfo.innerHTML = "Requesting webcam access...";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                
                // Try different constraints - ordered from most likely to work to least
                const constraints = [
                    { video: true, audio: false },
                    { video: { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false },
                    { video: { facingMode: "user" }, audio: false },
                    { video: { facingMode: "environment" }, audio: false }
                ];
                
                // Print out available devices for debugging
                navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        console.log(`Found ${videoDevices.length} video devices:`, videoDevices);
                        console.log("Current location: " + window.location.href);
                        console.log("Is secure context: " + window.isSecureContext);
                        
                        // Additional debugging for permissions
                        if (navigator.permissions) {
                            navigator.permissions.query({ name: 'camera' })
                                .then(permissionStatus => {
                                    console.log("Camera permission status:", permissionStatus.state);
                                    
                                    permissionStatus.onchange = () => {
                                        console.log("Camera permission changed to:", permissionStatus.state);
                                    };
                                })
                                .catch(err => {
                                    console.log("Error checking camera permission:", err);
                                });
                        } else {
                            console.log("Permissions API not available");
                        }
                        
                        if (videoDevices.length === 0) {
                            console.error("No video devices found");
                            loadingInfo.innerHTML = "No camera found on this device. Using static reflections instead.<br>Make sure you allow camera access and are using a secure context (https or localhost).";
                            loadingInfo.style.display = 'block';
                            loadingInfo.style.opacity = '1';
                            useStaticEnvironmentMap();
                            setTimeout(() => {
                                loadingInfo.style.opacity = '0';
                            }, 5000);
                            return;
                        }
                        
                        // Try each constraint until one works
                        tryConstraints(constraints, 0);
                    })
                    .catch(err => {
                        console.error("Error enumerating devices:", err);
                        // Still try to access webcam even if enumeration fails
                        tryConstraints(constraints, 0);
                    });
                
                function tryConstraints(constraintList, index) {
                    if (index >= constraintList.length) {
                        // All constraints failed, show error
                        console.error("No camera could be accessed after trying all options");
                        loadingInfo.innerHTML = "Could not access any camera. Using static reflections instead.";
                        useStaticEnvironmentMap();
                        setTimeout(() => {
                            loadingInfo.style.opacity = '0';
                        }, 3000);
                        return;
                    }
                    
                    console.log(`Trying constraint set ${index}:`, constraintList[index]);
                    
                    navigator.mediaDevices.getUserMedia(constraintList[index])
                        .then(function(stream) {
                            console.log("Webcam access granted with constraint set", index);
                            
                            // Ensure video tracks are enabled and active
                            const videoTracks = stream.getVideoTracks();
                            if (videoTracks.length === 0) {
                                console.error("No video tracks in stream");
                                throw new Error("No video tracks found");
                            }
                            
                            console.log("Video tracks:", videoTracks);
                            
                            // Assign the stream to the video element
                            webcamVideo.srcObject = stream;
                            
                            // Using both play() and the onloadedmetadata event for better compatibility
                            webcamVideo.onloadedmetadata = function() {
                                webcamVideo.play()
                                    .then(() => {
                                        console.log("Video playback started");
                                        // Show webcam feed in corner
                                        webcamVideo.style.display = 'block';
                                        
                                        // Make sure we're using a single shared material for all parts
                                        if (!sharedVideoMaterial) {
                                            sharedVideoMaterial = createVideoMaterial();
                                        }
                                                        // Apply the same material to all parts for seamless texture
                        modelMaterials.forEach(item => {
                            // Apply appropriate materials: video to left lens, synthwave to eyes, metal to others
                            if (item.isEyes) {
                                // Eyes always keep their synthwave glow
                                if (!sharedSynthwaveEyesMaterial) {
                                    sharedSynthwaveEyesMaterial = createSynthwaveEyesMaterial();
                                }
                                item.mesh.material = sharedSynthwaveEyesMaterial;
                                item.material = sharedSynthwaveEyesMaterial;
                            } else if (item.isLeftLens) {
                                const videoMaterial = createVideoMaterial(false);
                                item.mesh.material = videoMaterial;
                                item.material = videoMaterial;
                            } else {
                                if (!sharedMetalMaterial) {
                                    sharedMetalMaterial = createMetalMaterial();
                                }
                                item.mesh.material = sharedMetalMaterial;
                                item.material = sharedMetalMaterial;
                            }
                        });
                                        
                                        loadingInfo.innerHTML = "Webcam activated and applied as texture successfully!";
                                        loadingInfo.style.opacity = '1';
                                        loadingInfo.style.display = 'block';
                                        setTimeout(() => {
                                            loadingInfo.style.opacity = '0';
                                        }, 3000);
                                        
                                        // Start environment map updates
                                        updateEnvironmentMap();
                                    })
                                    .catch(e => {
                                        console.error("Error playing video:", e);
                                        loadingInfo.innerHTML = "Error starting video playback. Using static reflections.";
                                        useStaticEnvironmentMap();
                                    });
                            };
                            
                            webcamVideo.onerror = function() {
                                console.error("Video element error:", webcamVideo.error);
                                throw new Error("Video element error: " + webcamVideo.error);
                            };
                        })
                        .catch(function(error) {
                            console.error(`Error with constraint set ${index}:`, error);
                            // Try the next constraint
                            tryConstraints(constraintList, index + 1);
                        });
                }
            } else {
                console.warn("MediaDevices interface not supported");
                loadingInfo.innerHTML = "Your browser doesn't support webcam access. Using static reflections instead.";
                useStaticEnvironmentMap();
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
            }
        }
        
        // Initialize with static environment map first
        useStaticEnvironmentMap();
        
        // Load GLB model
        const loadingInfo = document.getElementById('loadingInfo');
        const loader = new GLTFLoader();
        
        loader.load(
            // Resource URL
            'copilot.glb',
            // Called when the resource is loaded
            function (gltf) {
                // Create a group to hold both original and mirrored models
                const modelGroup = new THREE.Group();
                scene.add(modelGroup);
                modelGroupRef = modelGroup; // Store reference for click detection
                
                // Store models for later material updates
                const originalModel = gltf.scene.clone();
                const mirroredModel = gltf.scene.clone();
                
                // First apply the scaling transformation to the mirrored model
                mirroredModel.scale.set(-1, 1, 1);
                
                // Apply UV mapping to both models - ensuring they share same UV coordinate space
                // Must do this after scaling the mirrored model
                applyUnifiedUVMapping(originalModel, false);
                applyUnifiedUVMapping(mirroredModel, true);
                
                // Create materials for the model
                const defaultMaterial = createMetalMaterial();
                const leftLensVideoMaterial = createVideoMaterial(false);
                
                // Create the synthwave eyes material
                if (!sharedSynthwaveEyesMaterial) {
                    sharedSynthwaveEyesMaterial = createSynthwaveEyesMaterial();
                }
                
                // Apply materials to the original model
                originalModel.traverse((child) => {
                    if (child.isMesh) {
                        // Debug: log all mesh names and positions to help identify the left lens
                        console.log("Mesh found:", child.name, "Position:", child.position);
                        console.log("  - Geometry vertices:", child.geometry?.attributes?.position?.count || 0);
                        
                        // Compute bounding box for more detailed position info
                        if (child.geometry) {
                            child.geometry.computeBoundingBox();
                            const box = child.geometry.boundingBox.clone();
                            box.applyMatrix4(child.matrixWorld);
                            const center = box.getCenter(new THREE.Vector3());
                            console.log("  - World bounding box center:", center);
                        }
                        
                        // Check mesh type and apply appropriate material
                        const isLeftLens = child.name === 'Glass';
                        const isEyes = child.name === 'Eyes';
                        
                        if (isEyes) {
                            child.material = sharedSynthwaveEyesMaterial;
                            console.log("âœ¨ Applied synthwave glow material to Eyes:", child.name);
                        } else if (isLeftLens) {
                            child.material = leftLensVideoMaterial;
                            console.log("âœ“ Applied video material to Glass lens:", child.name);
                        } else {
                            child.material = defaultMaterial;
                        }
                        
                        modelMaterials.push({
                            mesh: child,
                            material: child.material,
                            isMirrored: false,
                            isLeftLens: isLeftLens,
                            isEyes: isEyes,
                            meshIndex: modelMaterials.length,
                            meshName: child.name
                        });
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Apply materials to the mirrored model (all default material except Eyes)
                mirroredModel.traverse((child) => {
                    if (child.isMesh) {
                        const isEyes = child.name === 'Eyes';
                        
                        if (isEyes) {
                            child.material = sharedSynthwaveEyesMaterial;
                            console.log("âœ¨ Applied synthwave glow material to mirrored Eyes:", child.name);
                        } else {
                            child.material = defaultMaterial;
                        }
                        
                        modelMaterials.push({
                            mesh: child,
                            material: child.material,
                            isMirrored: true,
                            isLeftLens: false,
                            isEyes: isEyes
                        });
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Add models to the group
                modelGroup.add(originalModel);
                modelGroup.add(mirroredModel);
                
                // Center the entire group
                const box = new THREE.Box3().setFromObject(modelGroup);
                const center = box.getCenter(new THREE.Vector3());
                modelGroup.position.x = -center.x;
                modelGroup.position.y = -center.y;
                modelGroup.position.z = -center.z;
                
                // Adjust camera
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Zoom out a bit
                camera.position.z = cameraZ;
                
                // Update the camera's near and far planes
                camera.near = cameraZ / 100;
                camera.far = cameraZ * 100;
                camera.updateProjectionMatrix();
                
                // Update loading info
                loadingInfo.innerHTML = 'Model loaded successfully! Use mouse to rotate, scroll to zoom.';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                    setTimeout(() => {
                        loadingInfo.style.display = 'none';
                    }, 1000);
                }, 3000);
            },
            // Called while loading is progressing
            function (xhr) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                loadingInfo.innerHTML = 'Loading: ' + Math.round(percentComplete) + '%';
            },
            // Called when loading has errors
            function (error) {
                loadingInfo.innerHTML = 'Error loading model: ' + error.message;
                console.error('An error happened', error);
            }
        );

        // Function to apply a consistent UV mapping to the entire model
        function applyUnifiedUVMapping(model, isMirrored = false) {
            // Simplified UV mapping - use standard planar projection
            model.traverse(child => {
                if (child.isMesh && child.geometry) {
                    let uvs = child.geometry.attributes.uv;
                    if (!uvs) {
                        const positions = child.geometry.attributes.position;
                        const count = positions.count;
                        uvs = new THREE.Float32BufferAttribute(count * 2, 2);
                        child.geometry.setAttribute('uv', uvs);
                    }
                    
                    const positionAttribute = child.geometry.attributes.position;
                    const tempVertex = new THREE.Vector3();
                    
                    // Get bounding box for this specific mesh
                    child.geometry.computeBoundingBox();
                    const box = child.geometry.boundingBox;
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    
                    for (let i = 0; i < positionAttribute.count; i++) {
                        tempVertex.fromBufferAttribute(positionAttribute, i);
                        
                        // Use simple planar projection (front view)
                        let u = (tempVertex.x - box.min.x) / size.x;
                        let v = (tempVertex.y - box.min.y) / size.y;
                        
                        // Clamp to 0-1 range
                        u = Math.max(0, Math.min(1, u));
                        v = Math.max(0, Math.min(1, v));
                        
                        uvs.setXY(i, u, v);
                    }
                    
                    uvs.needsUpdate = true;
                }
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update synthwave time for pulsing glow effect
            synthwaveTime += 0.05;
            
            // Animate synthwave eyes glow
            if (sharedSynthwaveEyesMaterial) {
                // Create pulsing synthwave colors
                const hue1 = (Math.sin(synthwaveTime * 1.2) + 1) * 0.5; // 0-1 range
                const hue2 = (Math.sin(synthwaveTime * 0.8 + Math.PI) + 1) * 0.5; // 0-1 range offset
                
                // Mix between magenta/pink and cyan
                const mixedColor = new THREE.Color().setHSL(
                    0.8 + hue1 * 0.3, // Hue: purple to pink range
                    1.0, // Full saturation
                    0.5 + hue2 * 0.3 // Lightness variation
                );
                
                const mixedEmissive = new THREE.Color().setHSL(
                    0.5 + hue2 * 0.3, // Hue: cyan to blue range
                    1.0, // Full saturation
                    0.6 + hue1 * 0.4 // Lightness variation
                );
                
                sharedSynthwaveEyesMaterial.color = mixedColor;
                sharedSynthwaveEyesMaterial.emissive = mixedEmissive;
                sharedSynthwaveEyesMaterial.emissiveIntensity = 1.5 + Math.sin(synthwaveTime * 2) * 0.5; // Pulsing intensity
            }
            
            // Always update video texture if webcam has data
            if (webcamVideo.readyState === webcamVideo.HAVE_ENOUGH_DATA) {
                webcamTexture.needsUpdate = true;
            }
            
            controls.update(); // required if controls.enableDamping = true
            renderer.render(scene, camera);
        }

        animate();
        
        // Set default mode to texture so video is visible on the model
        currentMode = 'texture'; 
        
        // Automatically start webcam after page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Give the page a moment to initialize
            setTimeout(() => {
                startWebcam();
            }, 1000);
        });
        
        // Function to toggle between reflection and texture modes
        function toggleMode() {
            const toggleModeButton = document.getElementById('toggleModeButton');
            
            if (currentMode === 'reflection') {
                // Switch to texture mode
                currentMode = 'texture';
                toggleModeButton.textContent = "Switch to Reflection Mode";
                
                // Apply video material only to left lens, metal to others, eyes keep synthwave
                modelMaterials.forEach(item => {
                    if (item.isEyes) {
                        // Eyes always keep their synthwave glow
                        item.mesh.material = sharedSynthwaveEyesMaterial;
                        item.material = sharedSynthwaveEyesMaterial;
                    } else if (item.isLeftLens) {
                        const videoMaterial = createVideoMaterial(false);
                        item.mesh.material = videoMaterial;
                        item.material = videoMaterial;
                    } else {
                        if (!sharedMetalMaterial) {
                            sharedMetalMaterial = createMetalMaterial();
                        }
                        item.mesh.material = sharedMetalMaterial;
                        item.material = sharedMetalMaterial;
                    }
                });
                
                loadingInfo.innerHTML = "Video texture mode enabled. Your webcam is now applied to the left lens.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
                
            } else {
                // Switch back to reflection mode
                currentMode = 'reflection';
                toggleModeButton.textContent = "Switch to Texture Mode";
                
                // Create or reuse a single metal material
                if (!sharedMetalMaterial) {
                    sharedMetalMaterial = createMetalMaterial();
                }
                
                // Apply the same metal material to all parts except Eyes
                modelMaterials.forEach(item => {
                    if (item.isEyes) {
                        // Eyes always keep their synthwave glow
                        item.mesh.material = sharedSynthwaveEyesMaterial;
                    } else {
                        item.mesh.material = sharedMetalMaterial;
                    }
                });
                
                loadingInfo.innerHTML = "Reflection mode enabled. Your webcam provides environmental reflections.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
            }
        }
    </script>
</body>
</html>
