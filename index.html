<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copilot GLB Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .loading-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
            transition: opacity 0.5s;
        }
        #webcamVideo {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid white;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="loading-info" id="loadingInfo">Loading model...</div>
    <video id="webcamVideo" autoplay playsinline muted></video>
    <!-- Include the script at the end of the body for better performance -->
    <script src="share-modal.js" defer></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Create scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        // Create camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add point lights for better metallic reflections
        const pointLight1 = new THREE.PointLight(0xffffff, 1, 50);
        pointLight1.position.set(0, 10, 10);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.8, 50);
        pointLight2.position.set(-10, -5, -10);
        scene.add(pointLight2);

        // Add orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Initialize webcam
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamTexture = new THREE.VideoTexture(webcamVideo);
        webcamTexture.minFilter = THREE.LinearFilter;
        webcamTexture.magFilter = THREE.LinearFilter;
        webcamTexture.format = THREE.RGBAFormat;
        
        // Use webcam as environment map
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        let envMap;
        
        // Mode tracking
        let currentMode = 'reflection'; // 'reflection' or 'texture'
        
        // Initialize metal material with webcam reflection
        const createMetalMaterial = () => {
            return new THREE.MeshStandardMaterial({
                color: 0xC0C0C0, // Silver color
                metalness: 0.9,
                roughness: 0.1,
                envMap: envMap,
                envMapIntensity: 1.5,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });
        };
        
        // Initialize video texture material
        const createVideoMaterial = () => {
            return new THREE.MeshStandardMaterial({
                map: webcamTexture,
                metalness: 0.3,
                roughness: 0.5,
                envMap: envMap,
                envMapIntensity: 0.3,
                side: THREE.DoubleSide,
                transparent: false,
                opacity: 1.0
            });
        };
        
        // Metal materials array to update
        const modelMaterials = [];
        
        // Apply material to all meshes in a model
        const applyMaterialToModel = (model, materialType) => {
            model.traverse((child) => {
                if (child.isMesh) {
                    let material;
                    if (materialType === 'metal') {
                        material = createMetalMaterial();
                    } else if (materialType === 'video') {
                        material = createVideoMaterial();
                    }
                    
                    child.material = material;
                    modelMaterials.push({
                        mesh: child,
                        material: material
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        };

        // Function to load static environment map as fallback
        function useStaticEnvironmentMap() {
            console.log("Using static environment map as fallback");
            new THREE.TextureLoader().load(
                'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg', 
                function(texture) {
                    const envMapTexture = pmremGenerator.fromEquirectangular(texture).texture;
                    scene.environment = envMapTexture;
                    envMap = envMapTexture;
                    texture.dispose();
                }
            );
        }
        
        // Create dynamic environment map from webcam feed
        function updateEnvironmentMap() {
            try {
                // Only update if video is actually playing
                if (webcamVideo.readyState === webcamVideo.HAVE_ENOUGH_DATA) {
                    webcamTexture.needsUpdate = true;
                    
                    // Debug webcam status every few seconds
                    if (Math.random() < 0.01) { // ~1% chance each frame = occasional logging
                        console.log("Webcam active, dimensions:", webcamVideo.videoWidth, "x", webcamVideo.videoHeight);
                        console.log("Video texture update status:", webcamTexture.needsUpdate);
                    }
                    
                    try {
                        const webcamCubeRenderTarget = pmremGenerator.fromEquirectangular(webcamTexture);
                        envMap = webcamCubeRenderTarget.texture;
                        scene.environment = envMap;
                        
                        // Update all materials with new environment map (only in reflection mode)
                        if (currentMode === 'reflection') {
                            modelMaterials.forEach(item => {
                                if (item.mesh && item.mesh.material) {
                                    item.mesh.material.envMap = envMap;
                                    item.mesh.material.needsUpdate = true;
                                }
                            });
                        }
                        
                        webcamCubeRenderTarget.dispose();
                    } catch (renderError) {
                        console.error("Error generating environment map from webcam:", renderError);
                        // If we fail to create environment map from webcam, fall back to static
                        useStaticEnvironmentMap();
                        // Stop trying to update from webcam
                        return;
                    }
                } else {
                    console.log("Waiting for video data, current state:", webcamVideo.readyState);
                }
                
                // Continue updating
                requestAnimationFrame(updateEnvironmentMap);
            } catch (error) {
                console.error("Fatal error updating environment map:", error);
                // Fall back to static environment map
                useStaticEnvironmentMap();
            }
        }
        
        // Start webcam with explicit user interaction
        function startWebcam() {
            const startButton = document.getElementById('startButton');
            startButton.style.display = 'none';
            
            console.log("Starting webcam access...");
            
            // Check for secure context
            if (window.isSecureContext === false) {
                console.warn("Not in a secure context - webcam might not work");
                loadingInfo.innerHTML = "Warning: Site not in secure context. Webcam may not work. Try using HTTPS or localhost.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
            }
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                // Add loading message
                loadingInfo.innerHTML = "Requesting webcam access...";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                
                // Try different constraints - ordered from most likely to work to least
                const constraints = [
                    { video: true, audio: false },
                    { video: { width: { ideal: 640 }, height: { ideal: 480 } }, audio: false },
                    { video: { facingMode: "user" }, audio: false },
                    { video: { facingMode: "environment" }, audio: false }
                ];
                
                // Print out available devices for debugging
                navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        console.log(`Found ${videoDevices.length} video devices:`, videoDevices);
                        console.log("Current location: " + window.location.href);
                        console.log("Is secure context: " + window.isSecureContext);
                        
                        // Additional debugging for permissions
                        if (navigator.permissions) {
                            navigator.permissions.query({ name: 'camera' })
                                .then(permissionStatus => {
                                    console.log("Camera permission status:", permissionStatus.state);
                                    
                                    permissionStatus.onchange = () => {
                                        console.log("Camera permission changed to:", permissionStatus.state);
                                    };
                                })
                                .catch(err => {
                                    console.log("Error checking camera permission:", err);
                                });
                        } else {
                            console.log("Permissions API not available");
                        }
                        
                        if (videoDevices.length === 0) {
                            console.error("No video devices found");
                            loadingInfo.innerHTML = "No camera found on this device. Using static reflections instead.<br>Make sure you allow camera access and are using a secure context (https or localhost).";
                            loadingInfo.style.display = 'block';
                            loadingInfo.style.opacity = '1';
                            useStaticEnvironmentMap();
                            startButton.textContent = "No Camera Available";
                            startButton.style.opacity = "0.5";
                            startButton.style.display = 'block';
                            setTimeout(() => {
                                loadingInfo.style.opacity = '0';
                            }, 5000);
                            return;
                        }
                        
                        // Try each constraint until one works
                        tryConstraints(constraints, 0);
                    })
                    .catch(err => {
                        console.error("Error enumerating devices:", err);
                        // Still try to access webcam even if enumeration fails
                        tryConstraints(constraints, 0);
                    });
                
                function tryConstraints(constraintList, index) {
                    if (index >= constraintList.length) {
                        // All constraints failed, show error
                        console.error("No camera could be accessed after trying all options");
                        loadingInfo.innerHTML = "Could not access any camera. Using static reflections instead.";
                        useStaticEnvironmentMap();
                        startButton.textContent = "Camera Access Failed";
                        startButton.style.opacity = "0.5";
                        startButton.style.display = 'block';
                        setTimeout(() => {
                            loadingInfo.style.opacity = '0';
                        }, 3000);
                        return;
                    }
                    
                    console.log(`Trying constraint set ${index}:`, constraintList[index]);
                    
                    navigator.mediaDevices.getUserMedia(constraintList[index])
                        .then(function(stream) {
                            console.log("Webcam access granted with constraint set", index);
                            
                            // Ensure video tracks are enabled and active
                            const videoTracks = stream.getVideoTracks();
                            if (videoTracks.length === 0) {
                                console.error("No video tracks in stream");
                                throw new Error("No video tracks found");
                            }
                            
                            console.log("Video tracks:", videoTracks);
                            
                            // Assign the stream to the video element
                            webcamVideo.srcObject = stream;
                            
                            // Using both play() and the onloadedmetadata event for better compatibility
                            webcamVideo.onloadedmetadata = function() {
                                webcamVideo.play()
                                    .then(() => {
                                        console.log("Video playback started");
                                        // Show webcam feed in corner
                                        webcamVideo.style.display = 'block';
                                        
                                        // Apply video texture to all models
                                        modelMaterials.forEach(item => {
                                            const videoMaterial = createVideoMaterial();
                                            item.mesh.material = videoMaterial;
                                        });
                                        
                                        loadingInfo.innerHTML = "Webcam activated and applied as texture successfully!";
                                        loadingInfo.style.opacity = '1';
                                        loadingInfo.style.display = 'block';
                                        setTimeout(() => {
                                            loadingInfo.style.opacity = '0';
                                        }, 3000);
                                        
                                        // Start environment map updates
                                        updateEnvironmentMap();
                                    })
                                    .catch(e => {
                                        console.error("Error playing video:", e);
                                        loadingInfo.innerHTML = "Error starting video playback. Using static reflections.";
                                        useStaticEnvironmentMap();
                                        startButton.style.display = 'block';
                                    });
                            };
                            
                            webcamVideo.onerror = function() {
                                console.error("Video element error:", webcamVideo.error);
                                throw new Error("Video element error: " + webcamVideo.error);
                            };
                        })
                        .catch(function(error) {
                            console.error(`Error with constraint set ${index}:`, error);
                            // Try the next constraint
                            tryConstraints(constraintList, index + 1);
                        });
                }
            } else {
                console.warn("MediaDevices interface not supported");
                loadingInfo.innerHTML = "Your browser doesn't support webcam access. Using static reflections instead.";
                useStaticEnvironmentMap();
                startButton.textContent = "No Camera Support";
                startButton.style.opacity = "0.5";
                startButton.style.display = 'block';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
            }
        }
        
        // Initialize with static environment map first
        useStaticEnvironmentMap();
        
        // Load GLB model
        const loadingInfo = document.getElementById('loadingInfo');
        const loader = new GLTFLoader();
        
        loader.load(
            // Resource URL
            'copilot.glb',
            // Called when the resource is loaded
            function (gltf) {
                // Create a group to hold both original and mirrored models
                const modelGroup = new THREE.Group();
                scene.add(modelGroup);
                
                // Store models for later material updates
                const originalModel = gltf.scene.clone();
                const mirroredModel = gltf.scene.clone();
                
                // Apply video texture material by default
                applyMaterialToModel(originalModel, 'video');
                applyMaterialToModel(mirroredModel, 'video');
                
                // Apply a scaling transformation to mirror across the YZ plane (flip X axis)
                mirroredModel.scale.set(-1, 1, 1);
                
                // Add models to the group
                modelGroup.add(originalModel);
                modelGroup.add(mirroredModel);
                
                // Center the entire group
                const box = new THREE.Box3().setFromObject(modelGroup);
                const center = box.getCenter(new THREE.Vector3());
                modelGroup.position.x = -center.x;
                modelGroup.position.y = -center.y;
                modelGroup.position.z = -center.z;
                
                // Adjust camera
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Zoom out a bit
                camera.position.z = cameraZ;
                
                // Update the camera's near and far planes
                camera.near = cameraZ / 100;
                camera.far = cameraZ * 100;
                camera.updateProjectionMatrix();
                
                // Update loading info
                loadingInfo.innerHTML = 'Model loaded successfully! Use mouse to rotate, scroll to zoom.';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                    setTimeout(() => {
                        loadingInfo.style.display = 'none';
                    }, 1000);
                }, 3000);
            },
            // Called while loading is progressing
            function (xhr) {
                const percentComplete = xhr.loaded / xhr.total * 100;
                loadingInfo.innerHTML = 'Loading: ' + Math.round(percentComplete) + '%';
            },
            // Called when loading has errors
            function (error) {
                loadingInfo.innerHTML = 'Error loading model: ' + error.message;
                console.error('An error happened', error);
            }
        );

        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Always update video texture if webcam has data
            if (webcamVideo.readyState === webcamVideo.HAVE_ENOUGH_DATA) {
                webcamTexture.needsUpdate = true;
            }
            
            controls.update(); // required if controls.enableDamping = true
            renderer.render(scene, camera);
        }

        animate();
        
        // Set default mode to texture so video is visible on the model
        currentMode = 'texture'; 
        
        // Automatically start webcam after page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Give the page a moment to initialize
            setTimeout(() => {
                startWebcam();
            }, 1000);
        });
        
        // Function to toggle between reflection and texture modes
        function toggleMode() {
            const toggleModeButton = document.getElementById('toggleModeButton');
            
            if (currentMode === 'reflection') {
                // Switch to texture mode
                currentMode = 'texture';
                toggleModeButton.textContent = "Switch to Reflection Mode";
                
                // Change all materials to video texture
                modelMaterials.forEach(item => {
                    const videoMaterial = createVideoMaterial();
                    item.mesh.material = videoMaterial;
                });
                
                loadingInfo.innerHTML = "Video texture mode enabled. Your webcam is now applied as a texture.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
                
            } else {
                // Switch back to reflection mode
                currentMode = 'reflection';
                toggleModeButton.textContent = "Switch to Texture Mode";
                
                // Change all materials back to metal
                modelMaterials.forEach(item => {
                    const metalMaterial = createMetalMaterial();
                    item.mesh.material = metalMaterial;
                });
                
                loadingInfo.innerHTML = "Reflection mode enabled. Your webcam provides environmental reflections.";
                loadingInfo.style.opacity = '1';
                loadingInfo.style.display = 'block';
                setTimeout(() => {
                    loadingInfo.style.opacity = '0';
                }, 3000);
            }
        }
    </script>
</body>
</html>
